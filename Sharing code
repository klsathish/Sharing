Perfect üëç I‚Äôll guide you method-by-method how to refactor and how to use each properly in .NET Core 8 (clean architecture style).

We‚Äôll convert your old CommonUtils into proper services + helpers and show:

‚úî Where to place

‚úî How to register

‚úî How to use in Controller

‚úî How to use in Middleware

üîπ 1Ô∏è‚É£ GetCurrentSession ‚Üí Session Service
‚úÖ Model
public class CurrentSessionInfo
{
    public string UserId { get; set; } = string.Empty;
    public string SessionId { get; set; } = string.Empty;
    public string RoleId { get; set; } = string.Empty;
    public string DomainLoginId { get; set; } = string.Empty;
}

‚úÖ Interface
public interface ICurrentSessionService
{
    CurrentSessionInfo GetCurrentSession(HttpContext context);
}

‚úÖ Implementation
public class CurrentSessionService : ICurrentSessionService
{
    public CurrentSessionInfo GetCurrentSession(HttpContext context)
    {
        var claims = context.User.Identity as ClaimsIdentity;

        return new CurrentSessionInfo
        {
            UserId = claims?.FindFirst("uid")?.Value
                     ?? CommonMethod.GetUserName(context.User.Claims),

            SessionId = claims?.FindFirst("jti")?.Value ?? "",

            RoleId = claims?.FindFirst("rid")?.Value ?? "",

            DomainLoginId = claims?.FindFirst("domainLoginID")?.Value ?? ""
        };
    }
}

‚úÖ Register in Program.cs
builder.Services.AddScoped<ICurrentSessionService, CurrentSessionService>();

‚úÖ Use in Controller
private readonly ICurrentSessionService _sessionService;

public MyController(ICurrentSessionService sessionService)
{
    _sessionService = sessionService;
}

public IActionResult Test()
{
    var session = _sessionService.GetCurrentSession(HttpContext);

    return Ok(session.UserId);
}

‚úÖ Use in Middleware
public class LoggingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ICurrentSessionService _sessionService;

    public LoggingMiddleware(
        RequestDelegate next,
        ICurrentSessionService sessionService)
    {
        _next = next;
        _sessionService = sessionService;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var session = _sessionService.GetCurrentSession(context);

        await _next(context);
    }
}


Register:

app.UseMiddleware<LoggingMiddleware>();

üîπ 2Ô∏è‚É£ GetStatusFromException ‚Üí Exception Mapper (Static OK)

This has no dependency ‚Üí keep static.

‚úÖ Create
public static class ExceptionMapper
{
    public static string GetStatus(Exception ex)
    {
        return ex switch
        {
            ArgumentException => "Validation Error",
            UnauthorizedAccessException => "Unauthorized",
            SqlException => "Database Error",
            TimeoutException => "Timeout Error",
            _ => "Unhandled Exception"
        };
    }
}

‚úÖ Use Anywhere
catch (Exception ex)
{
    var message = ExceptionMapper.GetStatus(ex);
}

üîπ 3Ô∏è‚É£ GetRequestParameters ‚Üí Request Logger Helper

Since it uses HttpContext ‚Üí better as service.

‚úÖ Interface
public interface IRequestLoggingService
{
    string GetRequestParameters(HttpContext context);
    Task<string> ReadRequestBodyAsync(HttpRequest request);
    Task<string> ReadResponseBodyAsync(HttpResponse response);
}

‚úÖ Implementation
public class RequestLoggingService : IRequestLoggingService
{
    public string GetRequestParameters(HttpContext context)
    {
        var parameters = new Dictionary<string, object>();

        foreach (var (key, value) in context.Request.Query)
        {
            parameters[key] = value.ToString();
        }

        if (context.Request.HasFormContentType)
        {
            foreach (var (key, value) in context.Request.Form)
            {
                parameters[key] = value.ToString();
            }
        }

        return JsonSerializer.Serialize(parameters);
    }

    public async Task<string> ReadRequestBodyAsync(HttpRequest request)
    {
        request.EnableBuffering();
        request.Body.Seek(0, SeekOrigin.Begin);

        using var reader = new StreamReader(request.Body, leaveOpen: true);
        var body = await reader.ReadToEndAsync();

        request.Body.Seek(0, SeekOrigin.Begin);

        return body;
    }

    public async Task<string> ReadResponseBodyAsync(HttpResponse response)
    {
        response.Body.Seek(0, SeekOrigin.Begin);

        using var reader = new StreamReader(response.Body, leaveOpen: true);
        var body = await reader.ReadToEndAsync();

        response.Body.Seek(0, SeekOrigin.Begin);

        return body;
    }
}

‚úÖ Register
builder.Services.AddScoped<IRequestLoggingService, RequestLoggingService>();

‚úÖ Use Inside Middleware
public class RequestResponseMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IRequestLoggingService _loggingService;

    public RequestResponseMiddleware(
        RequestDelegate next,
        IRequestLoggingService loggingService)
    {
        _next = next;
        _loggingService = loggingService;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var parameters = _loggingService.GetRequestParameters(context);
        var requestBody = await _loggingService.ReadRequestBodyAsync(context.Request);

        await _next(context);
    }
}

üîπ 4Ô∏è‚É£ GetStatusCodeFromString ‚Üí Static HTTP Mapper

No dependency ‚Üí keep static.

public static class HttpStatusMapper
{
    public static int GetStatusCode(string message)
    {
        if (string.IsNullOrEmpty(message))
            return 500;

        if (message.Contains("Network Error")) return 503;
        if (message.Contains("Unauthorized")) return 401;
        if (message.Contains("not found")) return 404;

        return 500;
    }
}

üèó Final Folder Structure
Services/
   Session/
      ICurrentSessionService.cs
      CurrentSessionService.cs

   Logging/
      IRequestLoggingService.cs
      RequestLoggingService.cs

Utilities/
   ExceptionMapper.cs
   HttpStatusMapper.cs

Middleware/
   LoggingMiddleware.cs
   RequestResponseMiddleware.cs
