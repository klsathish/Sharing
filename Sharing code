Great üëç ‚Äî let‚Äôs do it the clean way using IMemoryCache in .NET.
You want:
‚úî Load all page URLs from DB
‚úî Store them in memory cache
‚úî Reuse them in middleware
‚úî Refresh only when needed
‚úÖ Step-by-Step Implementation
1Ô∏è‚É£ Register MemoryCache
In Program.cs
Copy code
Csharp
builder.Services.AddMemoryCache();
2Ô∏è‚É£ Create a Service to Load & Cache Page URLs
This keeps middleware clean üëç
Copy code
Csharp
public interface IPageService
{
    Task<List<string>> GetPageUrlsAsync();
}
Implementation
Copy code
Csharp
public class PageService : IPageService
{
    private readonly IMemoryCache _cache;
    private readonly MyDbContext _db;
    private const string CacheKey = "PAGE_URL_LIST";

    public PageService(IMemoryCache cache, MyDbContext db)
    {
        _cache = cache;
        _db = db;
    }

    public async Task<List<string>> GetPageUrlsAsync()
    {
        if (!_cache.TryGetValue(CacheKey, out List<string> urls))
        {
            urls = await _db.Pages
                .Select(x => x.ApiUrl)
                .ToListAsync();

            var cacheOptions = new MemoryCacheEntryOptions()
                .SetSlidingExpiration(TimeSpan.FromMinutes(30))   // reset if accessed
                .SetAbsoluteExpiration(TimeSpan.FromHours(4));     // refresh max time

            _cache.Set(CacheKey, urls, cacheOptions);
        }

        return urls;
    }
}
3Ô∏è‚É£ Register the Service
Copy code
Csharp
builder.Services.AddScoped<IPageService, PageService>();
4Ô∏è‚É£ Use It in Your Middleware
Copy code
Csharp
public class RoleAuthorizationMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IPageService _pageService;

    public RoleAuthorizationMiddleware(RequestDelegate next, IPageService pageService)
    {
        _next = next;
        _pageService = pageService;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var path = context.Request.Path.Value!.ToLower().TrimEnd('/');

        var pageUrls = await _pageService.GetPageUrlsAsync();

        bool isPageApi = pageUrls.Any(url =>
            path.StartsWith(url.ToLower(), StringComparison.OrdinalIgnoreCase));

        if (isPageApi)
        {
            var roleId = context.User.FindFirst("roleid")?.Value;

            bool hasAccess = await CheckRoleAccess(roleId, path);

            if (!hasAccess)
            {
                context.Response.StatusCode = 403;
                await context.Response.WriteAsync("Access denied.");
                return;
            }
        }

        await _next(context);
    }
}
üí® Performance Result
‚úî DB hit only once
‚úî Reused for 30 mins (or until restart)
‚úî Blazing fast middleware
‚úî You control cache policy
üîÅ Optional: Force Refresh Cache When Menu Updates
Add:
Copy code
Csharp
_cache.Remove("PAGE_URL_LIST");
After admin updates menu
(Example: inside save/update method)
üõ° Bonus Hardening
Normalize URLs before match:
Copy code
Csharp
path = path.Split('?')[0];
üéØ Summary
Feature
Status
Page APIs
üîê Role Checked
Chart/Grid APIs
üü¢ Auto Allowed
DB Load
‚ö° Cached
Code
Clean & maintainable
If you want, I can also help you:
‚úÖ add reload signal
‚úÖ add logging
‚úÖ unit test
‚úÖ Redis cache (for multi-server)
Just tell me üëç
[HttpPost("insertAPIRequestLogsAndPerformanceLogs")]
 public async Task<IActionResult> InsertAPIRequestLogsAndPerformanceLogs([FromBody] ApiRequestAndPerformanceLogRequest apiRequestAndPerformanceLogRequest)
 {
     ApiRequestAndPerformanceLogModel apiRequestAndPerformanceLogModel = new ApiRequestAndPerformanceLogModel();
     var loginSession = CommonUtils.GetCurrentSession(HttpContext);
     if (!string.IsNullOrEmpty(loginSession) && loginSession.Contains(":"))
     {
         var inpSes = loginSession.Split(':');
         apiRequestAndPerformanceLogModel.UserID = !string.IsNullOrEmpty(inpSes[0]) ? Int32.Parse(inpSes[0]) : 0;
         apiRequestAndPerformanceLogModel.SessionID = inpSes[1];
         apiRequestAndPerformanceLogModel.RoleID = !string.IsNullOrEmpty(inpSes[2]) ? Int32.Parse(inpSes[2]) : 0;
         apiRequestAndPerformanceLogModel.EmployeeName = inpSes[3];
         apiRequestAndPerformanceLogModel.CreatedBy = inpSes[3];
     }
     apiRequestAndPerformanceLogModel.CreatedOn = DateTime.Now;
     TimeSpan elapsedTime = apiRequestAndPerformanceLogRequest.ResponseTimeStamp - apiRequestAndPerformanceLogRequest.RequestTimeStamp;
     apiRequestAndPerformanceLogModel.Duration = $"{elapsedTime.TotalMilliseconds} ms";
     var response = await _iAPIRequestLogService.InsertAPIRequestLogsAndPerformanceLogs(apiRequestAndPerformanceLogRequest, apiRequestAndPerformanceLogModel);
     return StatusCode(response.StatusCode, response);
 }


[ExcludeFromCodeCoverage]
public class ApiRequestAndPerformanceLogRequest
{
    public int AppModuleMappingID { get; set; }
    public string? ApiEndPoint { get; set; }
    public string? RequestBody { get; set; }
    public string? HttpMethod { get; set; }
    public int? StatusCode { get; set; }
    public DateTime RequestTimeStamp { get; set; }
    public string? ResponseBody { get; set; }
    public DateTime ResponseTimeStamp { get; set; }
    public int? LayerID { get; set; }
    public string? ComponentName { get; set; }
    public string? ActionName { get; set; }
}
[ExcludeFromCodeCoverage]
public class ApiRequestAndPerformanceLogModel
{
    public int UserID { get; set; }
    public int RoleID { get; set; }
    public string? EmployeeName { get; set; }
    public string? RoleName { get; set; }
    public string? SessionID { get; set; }
    public string? Duration { get; set; }
    public string? CreatedBy { get; set; }
    public DateTime CreatedOn { get; set; }
}



        public async Task<string> InsertAPIRequestLogsAndPerformanceLogs(ApiRequestAndPerformanceLogRequest apiRequestAndPerformanceLogRequest, ApiRequestAndPerformanceLogModel apiRequestAndPerformanceLogModel)
        {
            var apiRequestLog = await _dbContext.Database.ExecuteSqlRawAsync("EXEC [dbo].[SP_Insert_Update_APIRequestLog] {0},{1},{2},{3},{4},{5},{6},{7},{8},{9},{10},{11},{12},{13},{14}"
                   , 0
                   , apiRequestAndPerformanceLogModel.UserID
                   , apiRequestAndPerformanceLogModel.RoleID
                   , apiRequestAndPerformanceLogModel.SessionID
                   , apiRequestAndPerformanceLogRequest.AppModuleMappingID
                   , apiRequestAndPerformanceLogRequest.ApiEndPoint
                   , apiRequestAndPerformanceLogRequest.HttpMethod
                   , apiRequestAndPerformanceLogRequest.StatusCode
                   , apiRequestAndPerformanceLogRequest.RequestBody
                   , apiRequestAndPerformanceLogRequest.RequestTimeStamp
                   , apiRequestAndPerformanceLogRequest.ResponseBody
                   , apiRequestAndPerformanceLogRequest.RequestTimeStamp
                   , apiRequestAndPerformanceLogModel.Duration
                   , apiRequestAndPerformanceLogModel.CreatedBy
                   , apiRequestAndPerformanceLogRequest.LayerID
                   );
            if (apiRequestLog == 0)
            {
                return SabicConstants.BadRequestMessage;
            }
            var performanceLog = await _dbContext.Database.ExecuteSqlRawAsync("EXEC [dbo].[SP_Insert_Update_PerformanceLog] {0},{1},{2},{3},{4},{5},{6},{7},{8},{9},{10}"
                   , 0
                   , apiRequestAndPerformanceLogModel.UserID
                   , apiRequestAndPerformanceLogModel.RoleID
                   , apiRequestAndPerformanceLogModel.SessionID
                   , apiRequestAndPerformanceLogRequest.ComponentName
                   , apiRequestAndPerformanceLogRequest.ActionName
                   , apiRequestAndPerformanceLogRequest.RequestTimeStamp
                   , apiRequestAndPerformanceLogRequest.ResponseTimeStamp
                   , apiRequestAndPerformanceLogModel.Duration
                   , apiRequestAndPerformanceLogModel.CreatedBy
                   , apiRequestAndPerformanceLogModel.CreatedOn
                   );
            if (performanceLog == 0)
            {
                return SabicConstants.BadRequestMessage;
            }
            return SabicConstants.SuccessMessage;
        }


need to work 
Performance Log - need to log every API call which are called, need to log from middleware not from react
Restrict the page access using role level routing from middleware  



----------------------


‚úÖ Middleware 1 ‚Äî Performance + API Request Log Middleware

This middleware:

Captures Request Timestamp

Reads body (optional)

Calls next()

Captures Response Timestamp

Reads session details (same as your code)

Calls your service method

You can adjust logs as needed

public class ApiLoggingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IAPIRequestLogService _logService;

    public ApiLoggingMiddleware(RequestDelegate next,
        IAPIRequestLogService logService)
    {
        _next = next;
        _logService = logService;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var requestTime = DateTime.Now;

        // READ REQUEST BODY
        context.Request.EnableBuffering();
        string requestBody = "";
        using (var reader = new StreamReader(context.Request.Body, leaveOpen: true))
        {
            requestBody = await reader.ReadToEndAsync();
            context.Request.Body.Position = 0;
        }

        // CALL API
        await _next(context);

        var responseTime = DateTime.Now;

        // READ SESSION (SAME AS YOUR CODE)
        var loginSession = CommonUtils.GetCurrentSession(context);

        var model = new ApiRequestAndPerformanceLogModel();

        if (!string.IsNullOrEmpty(loginSession) && loginSession.Contains(":"))
        {
            var inpSes = loginSession.Split(':');

            model.UserID = int.TryParse(inpSes[0], out var uid) ? uid : 0;
            model.SessionID = inpSes[1];
            model.RoleID = int.TryParse(inpSes[2], out var rid) ? rid : 0;
            model.EmployeeName = inpSes[3];
            model.CreatedBy = inpSes[3];
        }

        model.CreatedOn = DateTime.Now;
        model.Duration = (responseTime - requestTime).TotalMilliseconds + " ms";

        var apiReq = new ApiRequestAndPerformanceLogRequest
        {
            ApiEndPoint = context.Request.Path,
            HttpMethod = context.Request.Method,
            StatusCode = context.Response.StatusCode,
            RequestBody = requestBody,
            RequestTimeStamp = requestTime,
            ResponseTimeStamp = responseTime,
            ResponseBody = null, // If needed capture response
            ComponentName = "API",
            ActionName = context.Request.Path
        };

        await _logService.InsertAPIRequestLogsAndPerformanceLogs(apiReq, model);
    }
}

üöÄ Register Middleware (Program.cs)
app.UseMiddleware<ApiLoggingMiddleware>();


üëâ Put it after authentication but before MapControllers

app.UseAuthentication();
app.UseAuthorization();

app.UseMiddleware<ApiLoggingMiddleware>();

app.MapControllers();

üõë Middleware 2 ‚Äî Role Based Access Restriction
üéØ Requirement

Restrict endpoint based on role

Middleware should read role from session

‚úÖ Example Usage Pattern

You can define allowed role mapping like:

public static class RoleAccessConfig
{
    public static Dictionary<string, List<int>> RoleAccess = new()
    {
        { "/admin", new List<int>{1} }, // Only role 1
        { "/reports", new List<int>{1,2} }
    };
}

üîí Middleware Code
public class RoleAuthorizationMiddleware
{
    private readonly RequestDelegate _next;

    public RoleAuthorizationMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var path = context.Request.Path.ToString().ToLower();

        // Check if restriction exists
        var restricted = RoleAccessConfig.RoleAccess
            .FirstOrDefault(r => path.StartsWith(r.Key));

        if (!string.IsNullOrEmpty(restricted.Key))
        {
            var loginSession = CommonUtils.GetCurrentSession(context);

            int roleId = 0;

            if (!string.IsNullOrEmpty(loginSession)
                && loginSession.Contains(":"))
            {
                var inpSes = loginSession.Split(':');
                int.TryParse(inpSes[2], out roleId);
            }

            if (!restricted.Value.Contains(roleId))
            {
                context.Response.StatusCode = StatusCodes.Status403Forbidden;
                await context.Response.WriteAsync("Access Denied");
                return;
            }
        }

        await _next(context);
    }
}

üß© Register Role Middleware (Before Logging)
app.UseMiddleware<RoleAuthorizationMiddleware>();
app.UseMiddleware<ApiLoggingMiddleware>();

üéâ Result
====================

public class ApiLoggingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IAPIRequestLogService _logService;

    public ApiLoggingMiddleware(RequestDelegate next,
        IAPIRequestLogService logService)
    {
        _next = next;
        _logService = logService;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var requestTime = DateTime.Now;

        // ===== READ REQUEST BODY =====
        context.Request.EnableBuffering();
        string requestBody = "";
        using (var reader = new StreamReader(context.Request.Body, leaveOpen: true))
        {
            requestBody = await reader.ReadToEndAsync();
            context.Request.Body.Position = 0;
        }

        // ===== CAPTURE RESPONSE BODY =====
        var originalBodyStream = context.Response.Body;
        using var responseBodyStream = new MemoryStream();
        context.Response.Body = responseBodyStream;

        // ===== CALL NEXT MIDDLEWARE =====
        await _next(context);

        var responseTime = DateTime.Now;

        // ===== READ RESPONSE BODY =====
        context.Response.Body.Seek(0, SeekOrigin.Begin);
        var responseBody = await new StreamReader(context.Response.Body).ReadToEndAsync();
        context.Response.Body.Seek(0, SeekOrigin.Begin);

        // ===== COPY BACK TO ORIGINAL STREAM =====
        await responseBodyStream.CopyToAsync(originalBodyStream);

        // ===== READ SESSION DATA (SAME AS YOUR CODE) =====
        var loginSession = CommonUtils.GetCurrentSession(context);

        var model = new ApiRequestAndPerformanceLogModel();

        if (!string.IsNullOrEmpty(loginSession) && loginSession.Contains(":"))
        {
            var inpSes = loginSession.Split(':');

            model.UserID = int.TryParse(inpSes[0], out var uid) ? uid : 0;
            model.SessionID = inpSes[1];
            model.RoleID = int.TryParse(inpSes[2], out var rid) ? rid : 0;
            model.EmployeeName = inpSes[3];
            model.CreatedBy = inpSes[3];
        }

        model.CreatedOn = DateTime.Now;
        model.Duration = (responseTime - requestTime).TotalMilliseconds + " ms";

        var apiReq = new ApiRequestAndPerformanceLogRequest
        {
            ApiEndPoint = context.Request.Path,
            HttpMethod = context.Request.Method,
            StatusCode = context.Response.StatusCode,
            RequestBody = requestBody,
            RequestTimeStamp = requestTime,
            ResponseTimeStamp = responseTime,
            ResponseBody = responseBody,
            ComponentName = "API",
            ActionName = context.Request.Path
        };

        await _logService.InsertAPIRequestLogsAndPerformanceLogs(apiReq, model);
    }
}

-----

public class RoleAuthorizationMiddleware
{
    private readonly RequestDelegate _next;
    private readonly YourDbContext _db;

    public RoleAuthorizationMiddleware(RequestDelegate next, YourDbContext db)
    {
        _next = next;
        _db = db;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var path = context.Request.Path.ToString().ToLower();

        // Skip login / swagger / health check etc.
        if (path.Contains("login") || path.StartsWith("/swagger"))
        {
            await _next(context);
            return;
        }

        // ===== Read Session =====
        var loginSession = CommonUtils.GetCurrentSession(context);

        int roleId = 0;

        if (!string.IsNullOrEmpty(loginSession) && loginSession.Contains(":"))
        {
            var ses = loginSession.Split(':');

            // ses[2] = RoleId
            int.TryParse(ses[2], out roleId);
        }

        // If role not resolved -> not authorized
        if (roleId == 0)
        {
            context.Response.StatusCode = StatusCodes.Status401Unauthorized;
            await context.Response.WriteAsync("Role missing or invalid");
            return;
        }

        // ===== Call Stored Procedure =====
        var result = await _db.MyAccessChecks
            .FromSqlRaw(
                "EXEC SP_Validate_RolePageAccess {0}, {1}",
                roleId,
                path)
            .ToListAsync();

        var isAllowed = result.Any();

        if (!isAllowed)
        {
            context.Response.StatusCode = StatusCodes.Status403Forbidden;
            await context.Response.WriteAsync("Access Denied");
            return;
        }

        await _next(context);
    }
}

